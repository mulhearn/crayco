#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <cmath>
#include <vector>
#include <math.h>
#include "TFile.h"
#include "TH1.h"
#include "TRandom.h"
#include <iomanip>

#include "TMinuit.h"
#include <Math/ProbFuncMathCore.h>

using namespace std;

const double max_theta = 1.22; // 70 degrees
const double energy = 1.0e17;
const double rM = 79.0;// m (EAS page 199).
const double H = 10e3; // 100 km up

//  log (E) = a + b log (N)
//  log(e) - a = b log N
//  (log(E)-a)/b = log N
// exp ( log (E) - a / b ) = N
// a = 1.28, b = 0.92 (proton, http://particle.astro.ru.nl/pub/icrc09-1044.pdf)

double nch (double E)
{
  double a = 1.28;
  double b = 0.92;
  double N = exp( (log(E) - a) / b );
  return N;
}


double shower_pdf(double x, double y, double s_theta, double s_phi){
   // Debug with Gaussian:
   //const double gnorm = 1.0 / sqrt(2 * M_PI);
   //double dx = x/100*s_theta;
   //double dy = y/100*s_phi;
   //return gnorm * ( exp(-0.5*dx*dx)/(100*s_theta) * exp(-0.5*dy*dy)/(100*s_phi));

   //cout << s_theta << "\n";
   //cout << s_phi << "\n";

   // don't understand this yet, just copying from Daniel:
   double R = sqrt( x*x + y*y );
   double det_phi = std::atan2(y,x);      
   double r = 0.5*R * sqrt(3.0-cos(2*(det_phi-s_phi)) + 2*cos(det_phi-s_phi)*cos(det_phi-s_phi)*cos(2*s_theta));

   // from EAS, page 199, eq 4.162
   // with overall factor of N_e removed
   const double s = 1.0; // age ?
   double norm = (1.0/(2*3.14159*rM*rM)) * 1E6;
   double r1 = pow(r/rM,s-2);   
   double r2 = (double) pow( 1.0 + (r/rM),s-4.5);
   double gamma = tgammaf(4.5-s)/(tgammaf(s)*tgammaf(4.5-(2*s)));
   double pdf = norm*r1*r2*gamma;
   //cout << "r:  " << r << "\n";
   //cout << "pdf:  " << pdf << "\n";
   return pdf;
} 

double pull(double g, double x, double dx){ return (x-g) / dx; }

class shower_fcn {
public:
   // needed for TMinuit fcn interface
   static shower_fcn & instance(){ 
      static shower_fcn x;
      return x;
   }

   // the actual fcn using data from the class shower_fcn:
   double calc_fcn(double * par){
      const double norm = 1.0 / sqrt(2 * M_PI);
      double logl = 0.0;
      double logn = par[0];
      double theta = par[1];
      double phi = par[2];
      //cout << "theta:  " << theta << "\n";
      //cout << "phi:  " << phi << "\n";

      //double x = theta - gen_s_theta;
      //double y = phi - gen_s_phi;
      //logl = -x*x - y*y;

      for (int i=0; i<d_x.size();i++){
         double p  = shower_pdf(d_x[i], d_y[i], theta, phi);
         double mu = exp(logn) * p * d_xs;
         double p0 = ROOT::Math::poisson_cdf(0,mu);
         double p1 = 1.0 - p0;
         //cout << "mu:  " << mu << "\n";
         //cout << "p0:  " << p0 << "\n";
         //cout << "p1:  " << p1 << "\n";

         if (d_h[i]) logl += log(p1);
         else        logl += log(p0);
      }
      //cout << "logl =   " << logl << "\n";
      return -2.0*logl;
   }

   // detector data:
   vector<double> d_x;
   vector<double> d_y;
   vector<int>    d_h;
   //fixed parameters (for now)
   double d_xs;
   
   // parameters used for generating shower data:
   double gen_s_logn;
   double gen_s_theta;   
   double gen_s_phi;

   // fitted parameters:
   double fit_s_logn;
   double fit_s_theta;
   double fit_s_phi;
   double unc_s_logn;
   double unc_s_theta;
   double unc_s_phi;

private:
   shower_fcn(){}
};

// TMinuit fcn interface:
void fcn(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag)
{
   f = shower_fcn::instance().calc_fcn(par);
}


void generate(TRandom & rng, int s_logn, double s_theta, double s_phi, int d_n, double d_xs){ 
   const double norm = 1.0 / sqrt(2 * M_PI);
   shower_fcn & sfcn = shower_fcn::instance();
   sfcn.d_x.clear();
   sfcn.d_y.clear();
   sfcn.d_h.clear();
   sfcn.d_xs = d_xs;
   sfcn.gen_s_logn      = s_logn;
   sfcn.gen_s_theta   = fabs(s_theta);
   sfcn.gen_s_phi   = fabs(s_phi);

   for (int i=0; i<d_n; i++){
      double x = -500 + rng.Uniform() * 1000;
      double y = -500 + rng.Uniform() * 1000;
      double p = shower_pdf(x, y, s_theta, s_phi);
      double mu = p * exp(s_logn) * d_xs;
      double p0 = ROOT::Math::poisson_cdf(0,mu);

      double hit = 0;
      double xp = rng.Uniform();
      if (xp > p0) hit = 1;
      sfcn.d_x.push_back(x);
      sfcn.d_y.push_back(y);
      sfcn.d_h.push_back(hit);
   }
}

void do_fit(){
   shower_fcn & sfcn = shower_fcn::instance();


   int count_hits = 0;
   for (int i=0; i<sfcn.d_x.size(); i++){
      //cout << "x = " << sfcn.d_x[i] << " ";
      //cout << "y = " << sfcn.d_y[i] << " ";
      //cout << "h = " << sfcn.d_h[i] << "\n";
      if (sfcn.d_h[i] > 0) 
         count_hits++;
   }
   cout << "INFO:  number of phone hits " << count_hits << "\n";
   cout << "INFO:  number of phones " << sfcn.d_x.size() << "\n";


   TMinuit *gMinuit = new TMinuit(5);  //initialize TMinuit with a maximum of 5 params
   gMinuit->SetFCN(fcn);

   Double_t arglist[10];
   Int_t ierflg = 0;

   arglist[0] = 1;
   gMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
   
   // Set starting values and step sizes for parameters
   //static Double_t vstart[3] = {sfcn.gen_s_logn,  0.5,   0.5};
   static Double_t vstart[3] = {25.0,  0.5,   0.5};
   static Double_t step[3]   = {0.01, 0.01,  0.01};
   gMinuit->mnparm(0, "s_logn",   vstart[0], step[0], 0,     0,          ierflg);
   gMinuit->mnparm(1, "s_theta",  vstart[1], step[1], 0,     max_theta,  ierflg);
   gMinuit->mnparm(2, "s_phi",    vstart[2], step[2], -M_PI, M_PI,       ierflg);

   //gMinuit->FixParameter(0);
   
   // Now ready for minimization step
   arglist[0] = 1000;
   arglist[1] = 1.;
   gMinuit->mnexcm("MIGRAD", arglist ,2,ierflg);
   
   gMinuit->GetParameter(0, sfcn.fit_s_logn, sfcn.unc_s_logn);
   gMinuit->GetParameter(1, sfcn.fit_s_theta, sfcn.unc_s_theta);
   gMinuit->GetParameter(2, sfcn.fit_s_phi, sfcn.unc_s_phi);

   cout << "generated logn:   " << setw(12) << sfcn.gen_s_logn << " ";
   cout << "fitted value:     " << setw(12) << sfcn.fit_s_logn << " +/- " << sfcn.unc_s_logn << "\n";
   cout << "generated theta:  " << setw(12) << sfcn.gen_s_theta << " ";
   cout << "fitted value:     " << setw(12) << sfcn.fit_s_theta << " +/- " << sfcn.unc_s_theta << "\n";
   cout << "generated phi:    " << setw(12) << sfcn.gen_s_phi << " ";
   cout << "fitted value:     " << setw(12) << sfcn.fit_s_phi << " +/- " << sfcn.unc_s_phi << "\n";  
}


int main(int argc, char *argv[])
{
   TH1F hpn("hpn", "", 40, -3.0, 3.0);
   TH1F hpt("hpt", "", 40, -3.0, 3.0);
   TH1F hpp("hpp", "", 40, -3.0, 3.0);
   TH1F hde("hde", "", 40, -1.0, 1.0);
   TH1F hdp("hdp", "", 40, -1.0, 1.0);
   TH1F hdt("hdt", "", 40, -1.0, 1.0);


   TRandom rng;
   shower_fcn & sfcn = shower_fcn::instance();
   double s_logn = 28;
   double s_theta = 0.8;
   double s_phi =  0.5;
   int    d_n    = 10000;
   double d_xs   = 1E-15;

   cout << "s_n:  " << exp(s_logn) << "\n";

   for (int i=0; i<100; i++){
      generate(rng, s_logn, s_theta, s_phi, d_n, d_xs); 
      do_fit();
      double pull_logn  = pull(sfcn.gen_s_logn, sfcn.fit_s_logn, sfcn.unc_s_logn);
      double pull_theta = pull(sfcn.gen_s_theta, sfcn.fit_s_theta, sfcn.unc_s_theta);
      double pull_phi   = pull(sfcn.gen_s_phi, sfcn.fit_s_phi, sfcn.unc_s_phi);

      cout << "pull logn:   " << pull_logn << "\n";
      cout << "pull theta:  " << pull_theta << "\n";
      cout << "pull phi:    " << pull_phi << "\n";
      hpn.Fill(pull_logn);
      hpt.Fill(pull_theta);
      hpp.Fill(pull_phi);

      double dp = sfcn.fit_s_phi - sfcn.gen_s_phi;
      double dt = sfcn.fit_s_theta - sfcn.gen_s_theta;
      double e  = exp(s_logn);
      double ef = exp(sfcn.fit_s_logn);
      double de = (ef - e) / e;
      cout << "de:  " << de << "\n";
      
      hde.Fill(de);
      hdp.Fill(dp);
      hdt.Fill(dt);

   }

   TFile f("plots.root", "RECREATE");
   f.cd();
   hpn.Write();
   hpt.Write();
   hpp.Write();
   hde.Write();
   hdp.Write();
   hdt.Write();

   f.Close();

}

